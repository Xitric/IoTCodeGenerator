grammar org.iot.codegenerator.CodeGenerator with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate codeGenerator "http://www.iot.org/codegenerator/CodeGenerator"

// We are aware that this is questionable, but we will use a validator to
// ensure that board, fog, and cloud are not overwritten. This grammar is loose
// and allows for specifying things in any order
DeviceConf:
	language=Language (channels+=Channel | board+=Board | fog+=Fog | cloud+=Cloud)*
;

Language:
	'language' name=ID
;

Channel:
	'channel' name=ID
;

Board:
	'board' name=ID BEGIN
		'in' input=[Channel] sensors+=(ExtSensor | OnbSensor)+
	END
;

ExtSensor returns Sensor:
	{ExtSensor} 'extsensor' name=ID BEGIN
		sampler=Sampler datas+=Data+
	END
;

OnbSensor returns Sensor:
	{OnbSensor} 'onbsensor' name=ID BEGIN
		sampler=Sampler datas+=Data+
	END
;

Sampler:
	'sample' ({FrequencySampler} 'frequency' delay=INT | {SignalSampler} 'signal')
;

Data:
	'data' entities+=DataID (',' entities+=DataID)* BEGIN
		input = (I2C | Pin) 
		outputs += DataOut+
	END
;

DataID:
	name=ID
;

Source:
	I2C|Pin
;

I2C:
	'i2c' '(' address=HEX ')' 'as' name=ID vars=Vars 
;

Pin:
	'pin' '('ids+=INT (',' ids+=INT)* ')' 'as' name=ID vars=Vars
;

Vars:
	'(' ids+=VarID (',' ids+=VarID)* ')'
;

VarID:
	name=ID
;

DataOut:
	'out' channel=[Channel] dataId=[DataID] source=[Source] pipeline=Pipeline?
;

Pipeline:
	'.' (TuplePipeline | MapPipeline | WindowPipeline) (next=Pipeline)?
;

TuplePipeline:
	({Filter} 'filter' | {Abs} 'abs') '['expression=Expression']'
;

MapPipeline:
	{Map} 'map' '['expression=Expression '->' output=VarID ']'
;

WindowPipeline:
	'byWindow['width=INT']' '.' executePipeline=ExecutePipeline
;

ExecutePipeline:
    {Reduce} 'reduce' |
    {Mean} 'mean' |
    {Median} 'median' |
    {Mode} 'mode' |
    {Var} 'var' |
    {StDev} 'stdev' |
    {Min} 'min' |
    {Max} 'max' |
    {Count} 'count'
;

// The expression rules are loose allowing for meaningless expressions to be
// formed. Well-typedness will be ensured using validators
Expression:
	Conditional
;

// 4 == 4 ? yes : no, is per definition right associative
Conditional returns Expression:
	Or ({Conditional.condition=current} '?' correct=Conditional ':' incorrect=Conditional)?
;

// Implemented in a right-associative way just as an example - associativity
// does not matter for && and ||
Or returns Expression:
	And ({Or.left=current} '||' right=Or)?
;

And returns Expression:
	Equality ({And.left=current} '&&' right=And)?
;

Equality returns Expression:
	Comparison ({Equal.left=current} '==' right=Comparison | {Unequal.left = current} '!=' right=Comparison)*
;

Comparison returns Expression:
	SubAdd ({LessThan.left=current} '<' right=SubAdd | {LessThanEqual.left=current} '<=' right=SubAdd | {GreaterThan.left=current} '>' right=SubAdd | {GreaterThanEqual.left=current} '>=' right=SubAdd)*
;

SubAdd returns Expression:
	MulDiv ({Plus.left=current} '+' right=MulDiv | {Minus.left=current} '-' right=MulDiv)*
;

MulDiv returns Expression:
	Negation ({Mul.left=current} '*' right=Negation | {Div.left=current} '/' right=Negation)*
;

Negation returns Expression:
    {Negation} '-' value=Exponent | Exponent
;

// Exponentiation is right-associative!
// That is why the rule refers to itself (or its parent) on the right of the operator
Exponent returns Expression:
    Not ({Exponent.base=current} '**' power=Negation)?
;

Not returns Expression:
	{Not} '!' value=Primary | Primary
;

Primary returns Expression:
	'('Expression')' | NumberLiteral | BooleanLiteral | Reference | StringLiteral
;

Reference:
	varid=[VarID]
;

StringLiteral:
	value=STRING
;

NumberLiteral:
	value=NUMBER
;

BooleanLiteral:
	value=BOOLEAN
;

Fog:
	'fog' BEGIN
		transformations+=Transformation+ 
	END
;

Cloud:
	'cloud' BEGIN
		transformations+=Transformation+ 
	END
;

OutputDefinition:
	Transformation | Data
;

Transformation:
	'transformation' entities+=DataID (',' entities+=DataID)* BEGIN
		input=TransformationIn
		outputs+=TransformationOut+
	END
;

TransformationIn returns Source:
	{TransformationIn} 'in' entities=[DataID] 'as' name=ID vars=Vars
;

TransformationOut: 
	'out' entities=[DataID] source=[TransformationIn] pipeline=Pipeline?
;

terminal BEGIN: 'synthetic:BEGIN';
terminal END: 'synthetic:END';

@Override 
terminal INT returns ecore::EInt:
	'0' | ('1'..'9')('0'..'9')*
;
terminal HEX:
	'0x' ('0'..'9' | 'a'..'f' | 'A'..'F')+
;
terminal DBL returns ecore::EDouble:
	INT? '.'('0'..'9')+
;
terminal SCI returns ecore::EDouble:
	(INT | DBL) ('e' | 'E') '-'? INT
;
terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false'
;
NUMBER hidden():
	INT | HEX | DBL | SCI
;
