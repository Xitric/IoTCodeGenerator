/*
 * generated by Xtext 2.20.0
 */
package org.iot.codegenerator.scoping

import java.util.Collections
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.iot.codegenerator.codeGenerator.CodeGeneratorPackage
import org.iot.codegenerator.codeGenerator.Data
import org.iot.codegenerator.codeGenerator.Map
import org.iot.codegenerator.codeGenerator.Transformation
import org.iot.codegenerator.codeGenerator.Vars

import static extension org.eclipse.xtext.EcoreUtil2.*
import org.iot.codegenerator.codeGenerator.Pipeline

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CodeGeneratorScopeProvider extends AbstractCodeGeneratorScopeProvider {
	
	override getScope(EObject context, EReference reference){
		if (reference == CodeGeneratorPackage.eINSTANCE.reference_Varid){
			return context.scope
		}
		super.getScope(context, reference)
	}
	
	def private IScope getScope(EObject context){
		val mapContainer = context.eContainer.getContainerOfType(Pipeline)?.eContainer()?.getContainerOfType(Map)
		if (mapContainer !== null) {
			Scopes.scopeFor((Collections.singleton(mapContainer.output)))
		} else {
			val dataContainer = context.eContainer.getContainerOfType(Data)
			val tranContainer = context.eContainer.getContainerOfType(Transformation)
			val vars = dataContainer.getVariables(tranContainer)
			Scopes.scopeFor(vars.ids)	
		}
	}
	
	// var ids reside in both transformations and data inputs
	// these are added to the same scope
	def Vars getVariables(Data data, Transformation trans){
		if (data !== null){
			return data.input.vars
		} else if (trans !== null){
			return trans.input.vars
		}
	}
	
}
